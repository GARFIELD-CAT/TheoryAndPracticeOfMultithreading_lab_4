# Отчет по Многопоточному Приложению для Сбора и Обработки Данных

## 1. Описание Этапов Выполнения Задания

Данный проект реализует паттерн "Производитель-Потребитель" (Producer-Consumer) для параллельного сбора и обработки данных. Процесс был разделен на следующие этапы:

### Этап 1: Разработка `DataCollector` (Общий Ресурс)

*   **Цель:** Создать класс, который будет безопасно хранить и управлять общим набором данных (`Item`).
*   **Реализация:**
    *   Создан класс `DataCollector` с полями:
        *   `dataList` (ArrayList): для хранения собранных `Item`.
        *   `processedItems` (HashSet): для отслеживания уникальных ключей уже обработанных `Item`, предотвращая дублирование.
        *   `processedCount` (volatile int): для подсчета фактически обработанных элементов. `volatile` обеспечивает видимость изменений между потоками.
        *   `monitor` (Object): объект-монитор для синхронизации доступа к общим ресурсам.
    *   Реализованы методы для:
        *   `collectItem(Item item)`: добавление нового `Item`. Синхронизирован с помощью `synchronized(monitor)`, предотвращает добавление дубликатов и уведомляет ожидающие потоки (`notifyAll`).
        *   `incrementProcessed()`: инкремент счетчика обработанных элементов. Синхронизирован.
        *   `isAlreadyProcessed(String key)`: проверка и добавление ключа в `processedItems` для отслеживания. Синхронизирован.
        *   `waitForData()`: механизм ожидания для потребителей, использующий `monitor.wait()` с таймаутом. Освобождает блокировку во время ожидания.
        *   `getItem()`: извлечение одного `Item` из `dataList`. Синхронизирован.
*   **Ключевые концепции:** Использование `synchronized` блоков для обеспечения взаимного исключения, `volatile` для видимости, `wait`/`notifyAll` для межпоточного взаимодействия.

### Этап 2: Разработка `CollectorThread` (Производитель)

*   **Цель:** Создать потоки, которые будут генерировать `Item` и добавлять их в `DataCollector`.
*   **Реализация:**
    *   Создан класс `CollectorThread`, наследующий `Thread`.
    *   В конструкторе принимается `DataCollector`, количество элементов для генерации (`itemsToCollect`) и имя потока.
    *   Метод `run()`:
        *   В цикле генерирует уникальные `Item` (с уникальным ключом, включающим имя потока и временную метку).
        *   Добавляет сгенерированный `Item` в `DataCollector` с помощью `dataCollector.collectItem(item)`.
        *   Использует `Thread.sleep()` для имитации времени, затрачиваемого на генерацию данных.
*   **Ключевые концепции:** Генерация данных, асинхронное добавление в общий ресурс.

### Этап 3: Разработка `ProcessorThread` (Потребитель)

*   **Цель:** Создать потоки, которые будут извлекать `Item` из `DataCollector` и "обрабатывать" их.
*   **Реализация:**
    *   Создан класс `ProcessorThread`, наследующий `Thread`.
    *   В конструкторе принимается `DataCollector`, количество элементов для обработки (`itemsToProcess`) и имя потока.
    *   Метод `run()`:
        *   В цикле пытается получить `Item` из `DataCollector`.
        *   Использует `dataCollector.waitForData()` для ожидания появления данных.
        *   Извлекает `Item` с помощью `dataCollector.getItem()`.
        *   Если элемент успешно отмечен как "необработанный", он "обрабатывается" (имитация с `Thread.sleep()`), и вызывается `dataCollector.incrementProcessed()`.
        *   Использует `Thread.sleep()` для имитации времени обработки.
*   **Ключевые концепции:** Получение данных, ожидание, "обработка" данных, отслеживание обработанных элементов.

### Этап 4: Оркестрация в `DemoApplication`

*   **Цель:** Запустить тестовый сценарий, создав и управляя несколькими потоками-производителями и потребителями.
*   **Реализация:**
    *   Стандартный `main` метод Spring Boot приложения.
    *   Инициализация `DataCollector`.
    *   Определение параметров: количество сборщиков (`numCollectors`), обработчиков (`numProcessors`), элементов на сборщика (`itemsPerCollector`).
    *   Расчет общего количества элементов (`totalItems`) и элементов на обработчик (`itemsPerProcessor`).
    *   Создание и запуск списков `CollectorThread` и `ProcessorThread`.
    *   Использование `thread.join()` для ожидания завершения всех потоков.
    *   Вывод итоговой статистики: ожидаемое количество элементов, количество оставшихся в `dataList`, итоговое значение `processedCount`, количество уникальных ключей.
    *   Проверка корректности работы системы.
*   **Ключевые концепции:** Управление жизненным циклом потоков, установка тестовых условий, верификация результата.

## 2. Промежуточные Результаты и Выводы по Производительности

### Общие Наблюдения

*   **`DataCollector`:** Все методы, работающие с общими данными, защищены синхронизацией. Это гарантирует корректность, но может снижать производительность при большом количестве потоков.
*   **`ProcessorThread`:**
    *   `dataCollector.waitForData()` с таймаутом `1000` ms приводит к периодическим пробуждениям потоков, добавляя накладные расходы.

### Выводы по Производительности (Теоретические)

*   **`synchronized(monitor)`:** Является узким местом при высокой конкуренции.
*   **`volatile int processedCount`:** Достаточно для видимости, но `AtomicInteger` мог бы быть эффективнее для инкремента.

**Предлагаемые улучшения производительности:**

*   Заменить `volatile int processedCount` на `AtomicInteger`.
*   Удалить `synchronized (item.getKey().intern())` из `ProcessorThread`.
*   (Рекомендуется) Использовать `BlockingQueue` вместо ручного `wait/notify`.

## 3. Объяснение Использованных Методов Синхронизации и Предотвращения Deadlock

### Используемые Методы Синхронизации

1.  **`synchronized (Object monitor)` / `synchronized(this)`:**
    *   **Принцип:** Обеспечение **взаимного исключения**. Только один поток может одновременно выполнять код внутри `synchronized` блока, используя данный объект как блокировку.
    *   **Применение:** Защита доступа к `dataList`, `processedItems`, `processedCount` в `DataCollector`; предотвращение одновременной обработки одного элемента в `ProcessorThread`.

2.  **`volatile`:**
    *   **Принцип:** Гарантирует, что изменения значения переменной будут **немедленно видны** всем другим потокам.
    *   **Применение:** `volatile int processedCount` – для видимости изменений счетчика.

3.  **`wait()`, `notify()`, `notifyAll()`:**
    *   **Принцип:** Механизм **условного ожидания и уведомления**. Поток, владеющий монитором, может вызвать `wait()` для освобождения монитора и перехода в состояние ожидания, пока другой поток не вызовет `notify()` или `notifyAll()`.
    *   **Применение:** `DataCollector.waitForData()` (потребители ждут), `DataCollector.collectItem()` (`notifyAll` для пробуждения потребителей).

### Предотвращение Deadlock

*   **Методы предотвращения:**
    *   **Строгая иерархия блокировок:** Всегда захватывать блокировки в одном и том же порядке.
    *   **Использование `tryLock()`:** Позволяет избежать вечного ожидания.
    *   **Использование `BlockingQueue`:** Абстрагирует сложную логику ожидания/уведомления.
    *   **Ограничение времени ожидания блокировки:** Поток может отказаться от операции, если блокировка не получена вовремя.

## 4. Примеры Корректных и Некорректных Ситуаций (на примере перевода средств)

Представим, что `Item` - это транзакция перевода средств.

### Корректные Ситуации:

1.  **Уникальная транзакция, выполненная один раз:** `CollectorThread` добавляет транзакцию. `ProcessorThread` получает ее, `isAlreadyProcessed` возвращает `false`, перевод выполняется.
2.  **Транзакция, сгенерированная дважды, обработана один раз:** Если транзакция добавлена в очередь дважды, только первый `ProcessorThread` успешно ее обработает, а последующие обнаружат, что она уже в `processedItems`.

### Некорректные Ситуации (и как их избежать):

1.  **Двойное списание/зачисление (Без правильной синхронизации на уровне счетов):**
    *   **Проблема:** Если несколько `ProcessorThread` пытаются выполнить перевод с одного и того же счета без атомарной блокировки на уровне счета.
    *   **Решение:** Использовать `isAlreadyProcessed` и обеспечить атомарность операций в `BankService` (например, через блокировки на самих счетах).
2.  **Потеря транзакций (Если `waitForData` не работает корректно):**
    *   **Проблема:** `ProcessorThread` завершает свой фиксированный цикл итераций, не обработав все доступные данные.
    *   **Решение:** Использовать механизм оповещения о завершении сбора и модифицировать логику цикла `ProcessorThread`.
3.  **Deadlock при попытке блокировки счетов:**
    *   **Проблема:** Два потока блокируют счета в разном порядке (A->B и B->A), что приводит к взаимной блокировке.
    *   **Решение:** Строго придерживаться иерархии блокировок (например, блокировать счета по возрастанию ID).

## 5. Итоговые Выводы о Применении Синхронизации

*   **Необходимость:** Синхронизация **критически важна** при работе с общими, изменяемыми ресурсами в многопоточной среде для предотвращения состояний гонки и обеспечения целостности данных.
*   **Примитивы:**
    *   `synchronized`: Простой и надежный для взаимного исключения.
    *   `volatile`: Обеспечивает видимость, но не атомарность.
    *   `wait`/`notify`/`notifyAll`: Мощный, но сложный механизм, подверженный ошибкам.
